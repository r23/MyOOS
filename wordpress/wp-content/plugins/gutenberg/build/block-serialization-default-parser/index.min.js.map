{"version":3,"file":"./build/block-serialization-default-parser/index.min.js","mappings":"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","sources":["webpack://wp/webpack/bootstrap","webpack://wp/webpack/runtime/define property getters","webpack://wp/webpack/runtime/hasOwnProperty shorthand","webpack://wp/webpack/runtime/make namespace object","webpack://wp/./packages/block-serialization-default-parser/build-module/@wordpress/block-serialization-default-parser/src/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","let document;\nlet offset;\nlet output;\nlet stack;\n\n/**\n * Matches block comment delimiters\n *\n * While most of this pattern is straightforward the attribute parsing\n * incorporates a tricks to make sure we don't choke on specific input\n *\n *  - since JavaScript has no possessive quantifier or atomic grouping\n *    we are emulating it with a trick\n *\n *    we want a possessive quantifier or atomic group to prevent backtracking\n *    on the `}`s should we fail to match the remainder of the pattern\n *\n *    we can emulate this with a positive lookahead and back reference\n *    (a++)*c === ((?=(a+))\\1)*c\n *\n *    let's examine an example:\n *      - /(a+)*c/.test('aaaaaaaaaaaaad') fails after over 49,000 steps\n *      - /(a++)*c/.test('aaaaaaaaaaaaad') fails after 85 steps\n *      - /(?>a+)*c/.test('aaaaaaaaaaaaad') fails after 126 steps\n *\n *    this is because the possessive `++` and the atomic group `(?>)`\n *    tell the engine that all those `a`s belong together as a single group\n *    and so it won't split it up when stepping backwards to try and match\n *\n *    if we use /((?=(a+))\\1)*c/ then we get the same behavior as the atomic group\n *    or possessive and prevent the backtracking because the `a+` is matched but\n *    not captured. thus, we find the long string of `a`s and remember it, then\n *    reference it as a whole unit inside our pattern\n *\n *    @see http://instanceof.me/post/52245507631/regex-emulate-atomic-grouping-with-lookahead\n *    @see http://blog.stevenlevithan.com/archives/mimic-atomic-groups\n *    @see https://javascript.info/regexp-infinite-backtracking-problem\n *\n *    once browsers reliably support atomic grouping or possessive\n *    quantifiers natively we should remove this trick and simplify\n *\n * @type {RegExp}\n *\n * @since 3.8.0\n * @since 4.6.1 added optimization to prevent backtracking on attribute parsing\n */\nconst tokenizer = /<!--\\s+(\\/)?wp:([a-z][a-z0-9_-]*\\/)?([a-z][a-z0-9_-]*)\\s+({(?:(?=([^}]+|}+(?=})|(?!}\\s+\\/?-->)[^])*)\\5|[^]*?)}\\s+)?(\\/)?-->/g;\n\nfunction Block( blockName, attrs, innerBlocks, innerHTML, innerContent ) {\n\treturn {\n\t\tblockName,\n\t\tattrs,\n\t\tinnerBlocks,\n\t\tinnerHTML,\n\t\tinnerContent,\n\t};\n}\n\nfunction Freeform( innerHTML ) {\n\treturn Block( null, {}, [], innerHTML, [ innerHTML ] );\n}\n\nfunction Frame( block, tokenStart, tokenLength, prevOffset, leadingHtmlStart ) {\n\treturn {\n\t\tblock,\n\t\ttokenStart,\n\t\ttokenLength,\n\t\tprevOffset: prevOffset || tokenStart + tokenLength,\n\t\tleadingHtmlStart,\n\t};\n}\n\n/**\n * Parser function, that converts input HTML into a block based structure.\n *\n * @param {string} doc The HTML document to parse.\n *\n * @example\n * Input post:\n * ```html\n * <!-- wp:columns {\"columns\":3} -->\n * <div class=\"wp-block-columns has-3-columns\"><!-- wp:column -->\n * <div class=\"wp-block-column\"><!-- wp:paragraph -->\n * <p>Left</p>\n * <!-- /wp:paragraph --></div>\n * <!-- /wp:column -->\n *\n * <!-- wp:column -->\n * <div class=\"wp-block-column\"><!-- wp:paragraph -->\n * <p><strong>Middle</strong></p>\n * <!-- /wp:paragraph --></div>\n * <!-- /wp:column -->\n *\n * <!-- wp:column -->\n * <div class=\"wp-block-column\"></div>\n * <!-- /wp:column --></div>\n * <!-- /wp:columns -->\n * ```\n *\n * Parsing code:\n * ```js\n * import { parse } from '@wordpress/block-serialization-default-parser';\n *\n * parse( post ) === [\n *     {\n *         blockName: \"core/columns\",\n *         attrs: {\n *             columns: 3\n *         },\n *         innerBlocks: [\n *             {\n *                 blockName: \"core/column\",\n *                 attrs: null,\n *                 innerBlocks: [\n *                     {\n *                         blockName: \"core/paragraph\",\n *                         attrs: null,\n *                         innerBlocks: [],\n *                         innerHTML: \"\\n<p>Left</p>\\n\"\n *                     }\n *                 ],\n *                 innerHTML: '\\n<div class=\"wp-block-column\"></div>\\n'\n *             },\n *             {\n *                 blockName: \"core/column\",\n *                 attrs: null,\n *                 innerBlocks: [\n *                     {\n *                         blockName: \"core/paragraph\",\n *                         attrs: null,\n *                         innerBlocks: [],\n *                         innerHTML: \"\\n<p><strong>Middle</strong></p>\\n\"\n *                     }\n *                 ],\n *                 innerHTML: '\\n<div class=\"wp-block-column\"></div>\\n'\n *             },\n *             {\n *                 blockName: \"core/column\",\n *                 attrs: null,\n *                 innerBlocks: [],\n *                 innerHTML: '\\n<div class=\"wp-block-column\"></div>\\n'\n *             }\n *         ],\n *         innerHTML: '\\n<div class=\"wp-block-columns has-3-columns\">\\n\\n\\n\\n</div>\\n'\n *     }\n * ];\n * ```\n * @return {Array} A block-based representation of the input HTML.\n */\nexport const parse = ( doc ) => {\n\tdocument = doc;\n\toffset = 0;\n\toutput = [];\n\tstack = [];\n\ttokenizer.lastIndex = 0;\n\n\tdo {\n\t\t// twiddle our thumbs\n\t} while ( proceed() );\n\n\treturn output;\n};\n\nfunction proceed() {\n\tconst next = nextToken();\n\tconst [ tokenType, blockName, attrs, startOffset, tokenLength ] = next;\n\tconst stackDepth = stack.length;\n\n\t// We may have some HTML soup before the next block.\n\tconst leadingHtmlStart = startOffset > offset ? offset : null;\n\n\tswitch ( tokenType ) {\n\t\tcase 'no-more-tokens':\n\t\t\t// If not in a block then flush output.\n\t\t\tif ( 0 === stackDepth ) {\n\t\t\t\taddFreeform();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Otherwise we have a problem\n\t\t\t// This is an error\n\t\t\t// we have options\n\t\t\t//  - treat it all as freeform text\n\t\t\t//  - assume an implicit closer (easiest when not nesting)\n\n\t\t\t// For the easy case we'll assume an implicit closer.\n\t\t\tif ( 1 === stackDepth ) {\n\t\t\t\taddBlockFromStack();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// For the nested case where it's more difficult we'll\n\t\t\t// have to assume that multiple closers are missing\n\t\t\t// and so we'll collapse the whole stack piecewise.\n\t\t\twhile ( 0 < stack.length ) {\n\t\t\t\taddBlockFromStack();\n\t\t\t}\n\t\t\treturn false;\n\n\t\tcase 'void-block':\n\t\t\t// easy case is if we stumbled upon a void block\n\t\t\t// in the top-level of the document.\n\t\t\tif ( 0 === stackDepth ) {\n\t\t\t\tif ( null !== leadingHtmlStart ) {\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tFreeform(\n\t\t\t\t\t\t\tdocument.substr(\n\t\t\t\t\t\t\t\tleadingHtmlStart,\n\t\t\t\t\t\t\t\tstartOffset - leadingHtmlStart\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\toutput.push( Block( blockName, attrs, [], '', [] ) );\n\t\t\t\toffset = startOffset + tokenLength;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Otherwise we found an inner block.\n\t\t\taddInnerBlock(\n\t\t\t\tBlock( blockName, attrs, [], '', [] ),\n\t\t\t\tstartOffset,\n\t\t\t\ttokenLength\n\t\t\t);\n\t\t\toffset = startOffset + tokenLength;\n\t\t\treturn true;\n\n\t\tcase 'block-opener':\n\t\t\t// Track all newly-opened blocks on the stack.\n\t\t\tstack.push(\n\t\t\t\tFrame(\n\t\t\t\t\tBlock( blockName, attrs, [], '', [] ),\n\t\t\t\t\tstartOffset,\n\t\t\t\t\ttokenLength,\n\t\t\t\t\tstartOffset + tokenLength,\n\t\t\t\t\tleadingHtmlStart\n\t\t\t\t)\n\t\t\t);\n\t\t\toffset = startOffset + tokenLength;\n\t\t\treturn true;\n\n\t\tcase 'block-closer':\n\t\t\t// If we're missing an opener we're in trouble\n\t\t\t// This is an error.\n\t\t\tif ( 0 === stackDepth ) {\n\t\t\t\t// We have options\n\t\t\t\t//  - assume an implicit opener\n\t\t\t\t//  - assume _this_ is the opener\n\t\t\t\t// - give up and close out the document.\n\t\t\t\taddFreeform();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// If we're not nesting then this is easy - close the block.\n\t\t\tif ( 1 === stackDepth ) {\n\t\t\t\taddBlockFromStack( startOffset );\n\t\t\t\toffset = startOffset + tokenLength;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Otherwise we're nested and we have to close out the current\n\t\t\t// block and add it as a innerBlock to the parent.\n\t\t\tconst stackTop = stack.pop();\n\t\t\tconst html = document.substr(\n\t\t\t\tstackTop.prevOffset,\n\t\t\t\tstartOffset - stackTop.prevOffset\n\t\t\t);\n\t\t\tstackTop.block.innerHTML += html;\n\t\t\tstackTop.block.innerContent.push( html );\n\t\t\tstackTop.prevOffset = startOffset + tokenLength;\n\n\t\t\taddInnerBlock(\n\t\t\t\tstackTop.block,\n\t\t\t\tstackTop.tokenStart,\n\t\t\t\tstackTop.tokenLength,\n\t\t\t\tstartOffset + tokenLength\n\t\t\t);\n\t\t\toffset = startOffset + tokenLength;\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\t// This is an error.\n\t\t\taddFreeform();\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Parse JSON if valid, otherwise return null\n *\n * Note that JSON coming from the block comment\n * delimiters is constrained to be an object\n * and cannot be things like `true` or `null`\n *\n * @param {string} input JSON input string to parse\n * @return {Object|null} parsed JSON if valid\n */\nfunction parseJSON( input ) {\n\ttry {\n\t\treturn JSON.parse( input );\n\t} catch ( e ) {\n\t\treturn null;\n\t}\n}\n\nfunction nextToken() {\n\t// Aye the magic\n\t// we're using a single RegExp to tokenize the block comment delimiters\n\t// we're also using a trick here because the only difference between a\n\t// block opener and a block closer is the leading `/` before `wp:` (and\n\t// a closer has no attributes). we can trap them both and process the\n\t// match back in JavaScript to see which one it was.\n\tconst matches = tokenizer.exec( document );\n\n\t// We have no more tokens.\n\tif ( null === matches ) {\n\t\treturn [ 'no-more-tokens' ];\n\t}\n\n\tconst startedAt = matches.index;\n\tconst [\n\t\tmatch,\n\t\tcloserMatch,\n\t\tnamespaceMatch,\n\t\tnameMatch,\n\t\tattrsMatch /* Internal/unused. */,\n\t\t,\n\t\tvoidMatch,\n\t] = matches;\n\n\tconst length = match.length;\n\tconst isCloser = !! closerMatch;\n\tconst isVoid = !! voidMatch;\n\tconst namespace = namespaceMatch || 'core/';\n\tconst name = namespace + nameMatch;\n\tconst hasAttrs = !! attrsMatch;\n\tconst attrs = hasAttrs ? parseJSON( attrsMatch ) : {};\n\n\t// This state isn't allowed\n\t// This is an error.\n\tif ( isCloser && ( isVoid || hasAttrs ) ) {\n\t\t// We can ignore them since they don't hurt anything\n\t\t// we may warn against this at some point or reject it.\n\t}\n\n\tif ( isVoid ) {\n\t\treturn [ 'void-block', name, attrs, startedAt, length ];\n\t}\n\n\tif ( isCloser ) {\n\t\treturn [ 'block-closer', name, null, startedAt, length ];\n\t}\n\n\treturn [ 'block-opener', name, attrs, startedAt, length ];\n}\n\nfunction addFreeform( rawLength ) {\n\tconst length = rawLength ? rawLength : document.length - offset;\n\n\tif ( 0 === length ) {\n\t\treturn;\n\t}\n\n\toutput.push( Freeform( document.substr( offset, length ) ) );\n}\n\nfunction addInnerBlock( block, tokenStart, tokenLength, lastOffset ) {\n\tconst parent = stack[ stack.length - 1 ];\n\tparent.block.innerBlocks.push( block );\n\tconst html = document.substr(\n\t\tparent.prevOffset,\n\t\ttokenStart - parent.prevOffset\n\t);\n\n\tif ( html ) {\n\t\tparent.block.innerHTML += html;\n\t\tparent.block.innerContent.push( html );\n\t}\n\n\tparent.block.innerContent.push( null );\n\tparent.prevOffset = lastOffset ? lastOffset : tokenStart + tokenLength;\n}\n\nfunction addBlockFromStack( endOffset ) {\n\tconst { block, leadingHtmlStart, prevOffset, tokenStart } = stack.pop();\n\n\tconst html = endOffset\n\t\t? document.substr( prevOffset, endOffset - prevOffset )\n\t\t: document.substr( prevOffset );\n\n\tif ( html ) {\n\t\tblock.innerHTML += html;\n\t\tblock.innerContent.push( html );\n\t}\n\n\tif ( null !== leadingHtmlStart ) {\n\t\toutput.push(\n\t\t\tFreeform(\n\t\t\t\tdocument.substr(\n\t\t\t\t\tleadingHtmlStart,\n\t\t\t\t\ttokenStart - leadingHtmlStart\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\toutput.push( block );\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","document","offset","output","stack","tokenizer","Block","blockName","attrs","innerBlocks","innerHTML","innerContent","Freeform","parse","doc","lastIndex","proceed","next","matches","exec","startedAt","index","match","closerMatch","namespaceMatch","nameMatch","attrsMatch","voidMatch","length","isCloser","isVoid","name","input","JSON","e","parseJSON","nextToken","tokenType","startOffset","tokenLength","stackDepth","leadingHtmlStart","addFreeform","addBlockFromStack","push","substr","addInnerBlock","block","tokenStart","prevOffset","Frame","stackTop","pop","html","rawLength","lastOffset","parent","endOffset"],"sourceRoot":""}